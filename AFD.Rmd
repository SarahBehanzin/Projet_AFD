---
title: "AFD"
output: html_document
---

## Partie 1

* Librairies utilisées

````{r}
library(formattable)
library(rstatix)
````

* Importation des données

```{r}
rm(list = ls())
df  <- read.table('VIN_QUALITE.txt', header = T)
df$Quality <- factor(df$Quality)
N <- nrow(df)
head(df)
```
* On supprimme d'abord la colonne QUALITY pour pourvoir calculer les moyennes

```{r}
# df_change <- df[, ! names(df) %in% "Quality", drop = F]
# head(df_change)
```

* Moyenne des variables

````{r}
MoyVar <- colMeans(df[,1:4])
MoyVar
````
* Moyennes de variables par classe

````{r}
MoyVarClass <- aggregate(df[, 1:4], list(df$Quality), mean)
format_table(MoyVarClass)
````
* Matrice des Variances - Covariances par classes

````{r}
Df_C <- split(df[,1:4],df$Quality)

L <- lapply(Df_C,
  function(x){
  return(list(
    'CovClass' = var(x)*((nrow(x)-1)/nrow(x)),
    'nrow' = nrow(x),
    'mean' = list(
                  TP=mean(x$TP),
                  Sun=mean(x$Sun),
                  Heat=mean(x$Heat),
                  Rain=mean(x$Rain))
  )
  )
}
)
L

````

* Calcul des inerties : 

  * Calcul de l'inertie Intra (W) 
````{r}

# W <- list()
# for (i in 1:length(L)){
#   W <- (1/N)*sum((L[[i]]$nrow*(L[[i]]$CovClass)))
# }
# W

W <- (1/N)*((L$bad$nrow*(L$bad$CovClass))+(L$good$nrow*(L$good$CovClass))+(L$medium$nrow*(L$medium$CovClass)))
W
````
* Calcul des inerties : 

  * Calcul de l'inertie Inter (B) 
````{r}
B <- (1/N)*((L$bad$nrow*(unlist(L$bad$mean)-unlist(MoyVar))%*%t(unlist(L$bad$mean)-unlist(MoyVar)))+(L$good$nrow*(unlist(L$good$mean)- unlist(MoyVar))%*%t(unlist(L$good$mean)-unlist(MoyVar)))+(L$medium$nrow*(unlist(L$medium$mean)-unlist(MoyVar))%*%t(unlist(L$medium$mean)- unlist(MoyVar))))

B

````
* Calcul des inerties : 

  * Calcul de l'inertie Totale (I)
````{r}
I <- W+B
I
````
* Diagonalisation

  * Methode de Fisher
````{r}
k <- 3
p <- 4
Bp <- N/(k-1)*B
Bp
Wp <- N/(N-k)*W
Wp
````

````{r}
BW <- Bp%*%solve(Wp)
dBw <- eigen(BW)
U <- Re(dBw$vectors)[,1:2]
normes <- sqrt(diag(t(U)%*%W%*%U))

VecP <- sweep(U,2,normes,"/")
# fonction sweep permets d'appliquer une procédure à notre m, elle permet aussi de centrer et réduire les colonnes de la matrice 
VecPf <- VecP
rownames(VecPf)=c("TP","Sun","Heat","Rain")
colnames(VecPf)=c("Axe_1","Axe_2")


ValP <- matrix(Re(dBw$values)[1:2],2,1)
ValPf <- ValP
colnames(ValPf)=c("valeurs_propres")
rownames(ValPf)=c("Axe_1","Axe_2")

#petit p = 4
````

````{r}
inertie <- ValP/sum(ValP)*100
cor <- sqrt(ValP/(1+ValP))
Wilks <- (1-cor^2)
Kh2 <- -(N - (p+k)/2 -1)*log(Wilks)
res <- matrix(c(ValP,inertie,cor,Wilks,Kh2),2,5)
colnames(res)=c("valeur propres","% inertie","correlation","Wilks","Kh Deux")
rownames(res)= c("u1","u2")

````

## Partie 2

````{r}
library(ggplot2)

````

````{r}

````
